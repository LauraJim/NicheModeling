---
title: "Weighted-normal model: accounting for the uneven availability of environmental conditions"
author: "Laura Jiménez and Carola Franzen"
date: "June 2021"
output: html_document
fontsize: 12pt
linkcolor: dodgerblue4
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(raster)
library(rgdal)
library(rgeos)
library(tools)
library(scales)
library(ggplot2)
```
\

The estimation of the fundamental niche can be approached with the maximum likelihood estimation. It uses a weighted distribution where the weigths represent the availability of environmental combinations inside M. To calculate the maximum likelihood estimation, three functions are necessary: `rs.inE`, `negloglike`, and `like.max`.
\


\


\

# Function *fitNiche*

## Calculate the maximum likelihood for the fundamental niche
<!-- description-->


### Parameters

* `occ` = a matrix with occurrence and corresponding environmental data of a species
\

* `sam2` = a matrix containing a random sample of environmental combinations which come from the area of study (M)
\

\

### Dependencies

* `ggplot2`
\

* `ellipse`
\

\

## Functions Code

### How *fitNiche* works

The function `fitNiche` calculates the maximum likelihood estimation with a matrix of randomly sampled points within the study area (= result from the function `rs.inE`) and the occurrence data of a species that contains environmental data. At first, the mu and sigma of the occurrence data is calculated. Then, the sigma values are inverted. ###  <!-- description-->

```{r}
fitNiche <- function(E.occ, E.samM) {
  # calculate mu
  mu.ini <- colMeans(E.occ)
  # calculate A (covariance)
  Sig.ini <- cov(E.occ)
  # invert matrix sig.ini
  A.ini <- chol2inv(chol(Sig.ini))
  # whole vector of inicial values
  vals.ini <- c(mu.ini, A.ini[1,1], A.ini[1,2], A.ini[2,2])#c(mu.ini,A.ini[1,1],A.ini[1,2],A.ini[2,2])
  # fix the values of the samples used to evaluate the neg-log-likelihood
  like.fn <- function(theta){ negloglike(theta, sam1=E.occ, sam2=E.samM) } 
  find.mle <- optim(par=vals.ini, fn=like.fn, method="Nelder-Mead")
  mle <- find.mle$par
  mle.mu <- mle[1:2]
  mle.A <- matrix(c(mle[3:4],mle[4:5]),nrow=2,ncol=2)
  mle.Sig <- tryCatch(expr={chol2inv(chol(mle.A))}, error= function(e){NULL})
  
  # change column names for mle.Sig
  if(!is.null(mle.Sig)){
  colnames(mle.Sig) <- colnames(Sig.ini)
  rownames(mle.Sig) <- rownames(Sig.ini)
  }
    
  # wn = weighted normal distribution
  return(list(wn.mu = mle.mu, wn.sigma = mle.Sig, maha.mu = mu.ini, maha.sigma = Sig.ini))
}

```
\

The function has another function inside, called `negloglike`. Together with the function `rs.inE`, the input data can be transformed to generate the necessary parameters.

```{r}
negloglike <- function(guess, sam1, sam2){
  # define the parameters of interest from the guess parameter
  mu <- guess[1:2]
  A <- matrix(c(guess[3], guess[4], guess[4], guess[5]), nrow=2, ncol=2)
  # original sample size: number of presence points in the sample
  n <- nrow(sam1)
  # function that calculates quadratic terms, use inverse of matrix
  quad <- function(xi) { ax<-as.matrix(xi - mu); t(ax) %*% A %*% ax }
  q1 <- apply(sam1, 1, quad) # quadratic terms of presence points
  q2 <- apply(sam2, 1, quad) # quadratic terms of M points
  # negative log-likelihood value
  S <- 0.5*sum(q1) + n*log(sum(exp(-0.5*q2)))
  return(S)
}

```
\

### Output

The output is a list with four different objects: mu and sigma for the weigthed normal distribution, and mu and sigma for the distribution using Mahalanobis distance. This output can be used to calculate and plot ellipses in the environmental space.
\

\

## Worked examples

### Input Data

If the random sample has already been calculated (see above, function `rs.inE`), only the occurrence points of the species of interest are necessary as input data. These occurrence points do not need to contain geographical data but the environmental data. This matrix can be created by using the `get.ecoord` function (see tutorial "Function *get.ecoord*"). 
\

### *Catasticta nimbice*

Read the files necessary for the parameters of `rs.inE` and `fitNiche`.
```{r, results='hide'}
cn.shp <- readOGR("./Initial_Data/shapefiles","Catasticta_nimbice")

bio1 <- raster("./Initial_Data/bio1.asc")
bio12 <- raster("./Initial_Data/bio12.asc")

cn.occ <- read.csv("./Generated_Data/Catasticta_nimbice_occ_GE.csv",header=T)[,-(1:2)]
```
\

For the parameter `E.samM` the output of the function `rs.inE` is necessary.
```{r}
source(".\\Functions\\Trandom_sampling_inE.R")
```
\

Prepare parameters for `rs.inE`: create rasterstack.
```{r}
bios <- stack(bio1, bio12)
```
\

Apply the function `rs.inE`.
```{r}
cn.sample <- rs.inE(region = cn.shp,N = 10000,Estck = bios)
```
\

Apply the function with the parameters `E.occ` and `E.samM` (the sample `E.samM`` was calculated above and is named *sam.Mpnts*).
```{r, cache=TRUE}
ml <- fitNiche(E.occ = cn.occ, E.samM = cn.sample)
```
\

Create a new table with the output data and rename the columns. 
```{r}
ml.table <- cbind(ml$wn.mu, ml$wn.sigma, ml$maha.mu, ml$maha.sigma)
colnames(ml.table) <- c("wn.mu", "wn.sigma1", "wn.sigma2", "maha.mu", "maha.sigma1", "maha.sigma2")
```
\

Save the table as a csv-file.
```{r, eval=FALSE}
write.csv(ml.table,"./Generated_Data/cn_mu_sigma_estimates.csv",row.names = F)
```
\

Calculate the ellipses for the weighted distribution normal and the multivariate normal distribution.
```{r}
# get the ellipse defined by the ml estimators
el <- ellipse::ellipse(x=ml[[2]], centre=ml[[1]], level=0.99)
# get the ellipse from a multivarite normal model / mahalanobis distance method
el.ml <- ellipse::ellipse(x=ml[[4]], centre=ml[[3]], level=0.99)
```
\

Plot the environmental space with the sampled points, the occurrence points, the ellipse for the weigthed distribution and the ellipse from the Mahalanobis method. The plot will be saved as a png.
```{r, results='hide', fig.show='hide'}
# set colorpalette
colpal <- c("grey70", "chartreuse4", "coral2", "cadetblue3")

# plot will be saved as .png
png(paste0("./Generated_Data/Catasticta_nimbice","_mle.png"),width = 2300, height = 2300, 
    res = 600, pointsize = 6)
x11()
plot(cn.sample,col=colpal[1],pch=1, xlab="Annual mean temperature (°C*10)", 
     ylab="Annual precipitation (mm)")
# add presence points to the plot
points(cn.occ,col=colpal[3],pch=20,cex=1.5) # presences used in model
# ellipse maha
lines(el,col=colpal[2],lwd=2)
# ellipse mle
lines(el.ml,col=colpal[4],lwd=2)
sp.leg <- paste("Catasticta nimbice","(",nrow(cn.occ),")")
legend("topleft",legend = c(sp.leg,"Points inside M","Presences",
                            "Ellipse from Mahalanobis method",
                            "Ellipse from weighted-normal model"),
       pch=c(NA,1,19,NA,NA),col = c("white", colpal[1], colpal[3], colpal[2], colpal[4]),
       lwd=c(NA,NA,NA,2,2),bty = "n")
# finish saving png
dev.off()
```
\

```{r, echo=FALSE, fig.cap=" Figure of the environmental space of *Catasticta nimbice*. It shows the occurrence points of a species with two possible niches delineated by the Mahalanobis method and the weighted normal method.", out.width = '70%',fig.align="center"}
knitr::include_graphics("Images/Catasticta_nimbice_mle.png")
```
\

\

### *Threnetes ruckeri*

For this species the same steps are followed as above until the plot. Here, it will be plotted using `ggplot2`.
\

Read the matrix with occurrences combined with environmental data and the shape-file of the study area (the necessary rasterstack was already created in the example above).
```{r}
thr.occ <- read.csv("./Generated_Data/Threnetes_ruckeri_occ_GE.csv",header=T)[,-(1:2)]

thr.shp <- readOGR("./Initial_Data/shapefiles","Threnetes_ruckeri")
```
\

Sample random points from the area of interest using the `rs.inE` function with the parameters `region`, `N`, and `Estck`.
```{r}
thr.sample <- rs.inE(region = thr.shp, N = 5000, Estck = bios)
```
\

Apply function fit.Niche and change table.
```{r, cache=TRUE}
ml2 <- fitNiche(E.occ = thr.occ, E.samM = thr.sample)
# change function into proper table and rename column names
ml.table2 <- cbind(ml$wn.mu, ml$wn.sigma, ml$maha.mu, ml$maha.sigma)
colnames(ml.table2) <- c("wn.mu", "wn.sigma1", "wn.sigma2", "maha.mu", "maha.sigma1", "maha.sigma2")
```
\

Write results as a table.
```{r, eval=FALSE}
write.csv(ml.table2,"./Results/tr_mu_sigma_estimates.csv",row.names = F)
```
\

Calculate ellipses and change them into a dataframe.
```{r}
# get the ellipse defined by the ml estimators
el2 <- ellipse::ellipse(x=ml2[[2]], centre=ml2[[1]], level=0.99, npoints = 500)
df.el2 <- as.data.frame(el2)
colnames(df.el2) <- c("Temperature", "Precipitation")

# get the ellipse from a multivarite normal model / mahalanobis distance method
el.ml2 <- ellipse::ellipse(x=ml2[[4]], centre=ml2[[3]], level=0.99)
df.elml <- as.data.frame(el.ml2)
colnames(df.elml) <- c("Temperature", "Precipitation")
```
\

Plot in ggplot.
```{r}
# prepare data as a dataframe for ggplot
bckgrnd <- data.frame(Temperature = thr.sample[,1], Precipitation = thr.sample[,2])
species <- data.frame(Temperature = thr.occ[,1], Precipitation = thr.occ[,2])
data <- cbind(rbind(bckgrnd[,1:2], species[,1:2]), c(rep(1,nrow(bckgrnd)),rep(2,nrow(species))))
data2 <- data.frame(Temperature = data[, 1], Precipitation = data[, 2], 
                    Type = data[,3]) 

# plot
x11()
ggplot(data2, aes(x = Temperature, y = Precipitation)) +
  geom_point(aes(color = factor(Type), shape = factor(Type))) +
  scale_shape_manual(values=c(1, 19), guide = FALSE) +
  scale_color_manual(name= "Data",
                     labels= c("Background", "Presence"),
                     values= c("1"=colpal[1], "2"= colpal[3])) +
  theme(legend.position = c(.05, .95), # for x, value of 0 puts it  to the 
        # left side, value of 1 to the right, for y, value of 0 puts it to 
        # the bottom, # value of 1 puts it to the top
        legend.justification = c("left", "top")) +
  scale_x_continuous("Annual mean temperature (°C*10)") +
  scale_y_continuous("Annual precipitation (mm)") +
  # geom_path(data = df_el2, lineend="butt", linejoin="round", linemitre=1, show.legend = "Ellipse from weighted-normal model")
  geom_path(data = df.el2, color = colpal[2], size = 1.2) +
  geom_path(data = df.elml, color = colpal[4], size = 1.2)
```



